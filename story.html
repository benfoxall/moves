<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Moves</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="assets/other.css" charset="utf-8">
    <style>
      canvas {
          max-width: 100%;
          margin:auto;
      }

      code {
        position: relative;
        overflow: visible;
        -webkit-font-smoothing: antialiased;
      }

      .help-circle {
        width:100%;
        position: relative;
        margin-top:-1rem;
        margin-bottom: 2rem;
      }

      .help-circle button {
        position: absolute;
        height:48px;
        width:48px;
        /*right:12px;*/
        top:-34px;
        left: 50%;
        margin-left:-24px;

        border: none;
        border-radius: 50%;
        background: rgba(218, 42, 50, 0.9);
        box-shadow: rgba(0, 0, 0, 0.3) -2px 3px 5px;

        will-change: transform;
        transition: all .5s;

        cursor: pointer;
      }



      .no-help-move .help-circle.move{
        display: none;
      }

      .help-circle.move button.helping{
        box-shadow: rgba(0, 0, 0, 0.3) 0 0 0;
        transition: all .1s;
        border-radius: 45%;
      }

      .no-help-move .help-move-hint {
        display:none;
      }


      .help-circle.touch button.helping {
        transform: scale(0.01);
      }

      .help-circle.touch button {
        display: none;
      }

      .help-touch .help-circle.touch button{
        display: block
      }

      .help-move-hint, .help-touch-hint {
        border: 1px solid #fff;
        padding: 1em;
        background: rgba(218, 42, 50, 0.84);
        color: #fff;
        -webkit-font-smoothing: antialiased;
        border-radius: 10px;
      }

      .help-touch-hint {
        display:none;
      }

      .help-touch .help-touch-hint{
        display: block;
      }


      #game {
        /*height:200px;*/
        background: #ccc;
        text-align: center;
        padding:5%;
      }

      #game button {
        font-size: 2em;
        padding:1em;
        width:90%;

        will-change: opacity;
        transition: opacity .25s;
      }

      #move_graph_bar {
        display:block;
        font-size: 2em;
        padding:0;
        background: #333;
        width: 0;
        height: 1em;
        border-radius: 2px;
        will-change: width;
        margin: .5em 0;
      }

      @media print {
        .help-move-hint, .help-touch-hint, .help-circle {
          display: none;
        }
      }

    </style>

  </head>
  <body>

    <div class="content"><!-- I -->
    <article class="main-article"><!-- know -->
    <div class="description entry-content"><!-- html -->



<h1>SHHHHHH</h1>

<h3>This post is <u>unfinished</u> and <u>SECRET</u>, if you've come across it by accident, please don't share it.  (though tell me if you spot any mistakes!)</h3>

<hr />

<p>We’re going to make a game!</p>

<p>Our game is going to be based on <a href="http://www.jsjoust.com/">JSJoust</a>; where players have a controller which they keep still as possible whilst trying to force other players to move theirs.  It’s all done in time to Johann Sebastian Bach (hence the JS).</p>

<img src="assets/jsjoust.jpg" alt="players holding controllers, trying to push each other over" />

<p>You should definitely check it out.  In fact, if you stop reading this post, and go looking for some PS Move controllers to play it - I’d definitely count that as a success.</p>

<p>Hey, welcome back.</p>

<p>We’re going to build a version that doesn’t have any Bach (so, just “Joust”), but using Javascript (so, “JoustJS”).  We'll show the player how far they've moved by changing the colour of their screen.  When they've moved too much, we'll show that they've lost.</p>

<p><strong>Disclaimer time: <em>if you break your phone, it was't my fault<!--, it was probably Olivers. -->.</em></strong></p>

<h2>Detecting sudden movements</h2>

<p>We want to find out when a user makes a sudden movement. Rather than going straight for the orientation events, we’ll use mouse/touch position to make it easier to see what’s going on.</p>

<p>The rule we’re going to implement is: <strong>the cursor must cover no further than 300 pixels in 1.5 seconds.</strong></p>

<p>We need to store the cursor position, so lets write some javascript:</p>

<pre><code>class Point {
  constructor (x, y, prev) {

    this.x = x
    this.y = y

    this.timestamp = window.performance.now()

    if (prev) prev.next = this

  }
}

// store the most recent point
let current = null

// helper function for adding mouse/touch
// move listeners
move(
  (x, y) => {
    current = new Point(x, y, current)
  }
)

/*
* current:
* <span data-key="move_current">{
*  x:…,
*  y:…,
*  timestamp:…
* }</span>
*/
</code></pre>
<div class="help-circle touch"><button data-help="touch"></button></div>

<p class="help-touch-hint"><em>If you're on a touch device, drag from the circle above to prevent scrolling (it'll help you see what’s going on)</em></p>

<p>This javascript looks kind of weird&hellip; That’s because we’re using class, let, and arrow function syntax from es2015.  At some point in the future (probably not 2015) it'll be totally cool to use this in browsers, but for now it’s safest to transform it into es5 using a tool such as Babel. <!-- To see an example of this kind of workflow (and the compiled es5 files) check out {{{LINK TO REPO}}}.--></p>

<p>As well as storing the pointer coordinates, we're storing the time that it was stored using <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">performance.now()</a></code>, which allows us to check if the point happened in a particular timespan.</p>

<p>We're also linking the last point <strong>toward</strong> the next, creating a <a href="https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list">singly linked list</a>.  This means that we’ve got <strong>no way of accessing previous points</strong> - which is actually kinda good, because the browser can detect that, and garbage collect old data.</p>

<p>When we do want to access the data, we can store a reference to the current point, and then any subsequent points are accessible by traversing the <code>.next</code> property.</p>


<pre><code>function* points(p) {
  do yield p
  while (p = p.next)
}

// our starting point
let start = null

const traverse = (timestamp) => {
  requestAnimationFrame(traverse)

  if (!current) return

  // move forward until we are
  // within 1.5 seconds of now
  for(start of points(start || current))
    if(past.timestamp > timestamp - 1500)
      break
}
requestAnimationFrame(traverse)

/**
* points(start):<div data-key="move_list"><canvas height="200" width="500"></canvas></div>*/
</code></pre>
<div class="help-circle touch"><button data-help="touch"></button></div>


<p>Right. Some things:</p>

<ul>
  <li>`points` is a generator function which lets us traverse through our stored points in a `for … of` loop.</li>
  <li>We’re calling the render function with `requestAnimationFrame`, this means that the rendering will be called in sync with the browser refresh, and pause when the tab isn’t visible.</li>
  <li>Our <code>render</code> function is being given a `timestamp` variable, this is the equivalent of calling `window.performance.now()`, which lets us compare to the timestamps generated in Point.</li>
</ul>

<p>Now that we’ve got access to this data, we can calculate how far the pointer has moved. We’ll define this as the diagonal length of the bounding box of points - that way it’s a bit more robust to wobbly/shaky input.
.</p>

<pre><code data-key="move_calculation">const range = (points) => {

  let x_min, x_max, y_min, y_max, first = true;

  for(let n of points) {
      if(first){
          x_min = x_max = n.x;
          y_min = y_max = n.y;
          first = false;
          continue;
      }

      if (n.x < x_min) {x_min = n.x}
      else if (n.x > x_max ) {x_max = n.x}

      if (n.y < y_min) {y_min = n.y}
      else if (n.y > y_max) {y_max = n.y}
  }

  return {
    x: {min: x_min, max: x_max},
    y: {min: y_min, max: y_max}
  }
}

/*
* Range of points over last 1.5s:
*  <span id="move_calculation_range">x: …, y = …</span>
*/


const extent = (range) => ({
  x: range.x.max - range.x.min,
  y: range.y.max - range.y.min
})

/*
* Extent of those points:
*  <span id="move_calculation_extent">x = 0, y = 0</span>
*/


const distance (e) =>
  Math.sqrt(
    Math.pow(e.x, 2) +
    Math.pow(e.y, 2)
  )
/*
* Distance covered:
*  <span id="move_calculation_distance">0</span>
*/

</code></pre>
<div class="help-circle touch"><button data-help="touch"></button></div>

<p>Now we've got the distance, we can use it to implement our "too fast" rule.</p>

<pre><code>// scale the distance, so we can use
// different rules later
const scale = (d) => Math.min(1, d / 300)

const tooFast = (s) => s === 1

/*<span data-key="move_graph"><span id="move_graph_text">
* scaled: _
* toFast: _</span>
* <span id="move_graph_bar"></span>*/
</code></pre>
<div class="help-circle touch"><button data-help="touch"></button></div>

<p>Great.</p>

<p>Now we've got the data we need for the game, we just need to display it to the user</p>

<h2>Colours</h2>

<p>Because it's christmas, the transition will be from green (all good) to red (too fast). We'll need a function that converts our distance to a colour.</p>

<p>Colour interpolation can be kind of tricky; in our case, changing the rgb components of #f00 to #0f0 will result in a bit of a murky brown bit in the middle.</p>

<p>One way around this is to use HSL colour space, varying the hue from green (120) to red (0) and keeping the brightness and saturation constant. This also means the colour will sweep through yellow and orange (which are also pretty christmassy).</p>


<pre><code data-key="colour_calculation">
const colour =
  d => `hsl(${~~((1-d) * 120)}, 100%, 45%)`

/*
* <span id="colour_calculation_colour">_</span>
*
<div id="colour_calculation_out" style="width:100%; height:150px;"> </div>
*/</code></pre>


<p>Cool.</p>


<h2>Movement</h2>

<p>Right, we've got all that stuff now - lets use it to track the movement of our device.</p>

<p>We can listen for <code>deviceorientation</code> events in our browser.  This tells us which way the device is pointing through the event <code>gamma</code>, <code>alpha</code> &amp; <code>beta</code> properties.</p>


<pre><code data-key="orientation_current">{
  gamma:     _,
  alpha:     _,
  beta:      _,
  timestamp: _
}</code></pre>

<div class="help-circle move"><button data-help="move"></button></div>

<p class="help-move-hint"><em>To emulate some device orientation events, drag the red circle above</em></p>

<p>We can use these properties to tell how far the device has rotated with the same functions we had before that we did before (with a little bit of updating to support a third property).</p>


<pre><code>/*
* orientation points:
<canvas height="200" width="300" data-key="orientation_graph"></canvas>
*
* distance: …
*/
</code></pre>

<div class="help-circle move"><button data-help="move"></button></div>



<p>There’s a problem - when the alpha goes past 360 degrees, it’ll continue on from 0, which causes a big jump in distance, and makes us falsely detect a sudden movement.</p>

<p>We can get around this by mapping our values to <code>0&rarr;2&Pi;</code>, then pressing the <code>Math.Sin</code> key on our calculators.  This means that <code>0</code> &amp; <code>360</code> will both become <code>1</code>, and <code>180</code> will become <code>-1</code>.  It's not a terribly great approach for a number of reasons - but it'll do the job.</p>


<pre><code>const PI2 = 2 * Math.PI

const convert = p => ({
    alpha: Math.sin(PI2 * (p.alpha / 360)),
    beta:  Math.sin(PI2 * (p.beta  / 360)),
    gamma: Math.sin(PI2 * (p.gamma / 180))
})

/*
* converted: <span data-key="orientation_convert">
*   gamma = _
*   alpha = _
*   beta  = _</span>
*/
</code></pre>

<div class="help-circle move"><button data-help="move"></button></div>

<p>Now our distance doesn't jump around.  Though it's a lot smaller than before (-1 -> 1), so we can update our `scale` function to reflect that.</p>

<h2>Game state</h2>

<p>It's not quite a game yet, for that we need to give players a way to start playing, and to lose.  We can think of this as a series of states:</p>

<pre><code>[ready, started, lost]</code></pre>

<p>And some transitions between the states:</p>

<pre><code>[start, lose]</code></pre>

<p><em>There's a depressing absence of `<code>won/win</code>` here. That's because our devices aren’t connected together, so we can’t really tell if there is anyone else left. I'll be talking about this bit at <a href="https://www.frontierconf.com/">Frontier Conf</a> in March - you should come along.</em></p>

<p>Now we've got the model

  We can model this game logic with something like:</p>


<pre><code>const READY = 1,
      STARTED = 2,
      LOST = 4

let state = READY

function start () {
  if(state &amp; READY | LOST) {
    hideButton()
    state = STARTED
  }
}

function lose () {
  if(state &amp; STARTED) {
    showButton()
    state = LOST
  }
}

// state = <span data-key="state_code">READY</span>
</code></pre>

<div data-key="state_game" id="game">
  <button id="state_game_button">START</button>
</div>

<p></p>
<div class="help-circle move"><button data-help="move"></button></div>


<p>done!</p>


<h2>The rest of the owl</h2>


<p>Now we can add some more stuff:</p>

<ul>
<li>some html - because it’s a webpage</li>
<li>a manifest file - so we can launch in fullscreen and lock the orientation</li>
<li>a cool little script by Max to change the heading colour to make the url bar awesome</li>
<li>Vibrate and Audio feedback so you know when you’ve lost</li>
<li>a service worker - to allow this to all happen offline.</li>
<li>A big button to take you to it</li>
</ul>






<script src="es5/polyfill.js"></script>
<script src="es5/story.js"></script>

</body>
</html>
